<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Gem Mines RPG - Tile Dragging Mechanic</title>
</head>
<link href='http://fonts.googleapis.com/css?family=Varela+Round' rel='stylesheet' type='text/css'>
<link href='css/game.css' rel='stylesheet' type='text/css'>

<body oncontextmenu="return false">
<div id="grid">
	<div id="tooltip"></div>
</div>
<div id="msg"></div>
<div id="score">Score: 0</div>

<script src="js/Player.js"></script>
<script src="js/Tile.js"></script>
<script src="js/Time.js"></script>
<script src="js/Tooltip.js"></script>

<script src="js/test-data-1.js"></script>

<script>
var und;

var game = {
	time: new Time(),
	player: {},
	tiles: [],
	tileDims: 0,
	score: 0,
	mouseDown: false,
	colors: [ ],
	tooltips: [ ],
	dragPath: {
		color: '',
		tiles: [],
		minimum: 2,
		lastTile: 0,
		lastX: 0,
		lastY: 0
	},
	mouse: {
		position: {
			x:0,
			y:0,
		}
	},
	moving: {
		status: false,
		path: []
	},
	init: function ( grd, dims ) {//, tilesX, tilesY ) {
		//console.log( "INIT game" );
		this.resize();
	//	this.removeChildren();
		this.tiles.length = 0;
		this.tileDims = dims;
		
		this.time.init(); // start timer
	},
	update: function () {
		this.time.update();
		
		if( this.moving.status == true ) {
			var lastPlayerPosition = this.player.position;
			console.log( lastPlayerPosition );
			
			var destination = this.tiles[ this.moving.path[ 0 ] ].actual;
			this.player.move( destination, this.time.delta );
			
			//console.log( destination.x + " -- " + this.player.position.actual.x );
			if( this.player.position.actual.x == destination.x && 
				this.player.position.actual.y == destination.y ) {
				
				// flip the last tile
				var findLastTilePos = this.findDivAt( 
					lastPlayerPosition.x,
					lastPlayerPosition.y
				);
				findLastTilePos.tile.flipTile( this.getRandomColor() );
				// clear the next tile
				this.tiles[ this.moving.path[ 0 ] ].clearTile( );
				/*var findTileNum = this.findDivAt( 
					this.tiles[ this.moving.path[ 0 ] ].x,
					this.tiles[ this.moving.path[ 0 ] ].y
				);*/
				//console.log( "flip:" + findTileNum ); // @aseaboyer - flip the tile the player WAS on instead
				//console.log( findTileNum ); // @aseaboyer - flip the tile the player WAS on instead
				
				// at a tile, 
				this.player.position.set( this.tiles[ this.moving.path[ 0 ] ].x, this.tiles[ this.moving.path[ 0 ] ].y );
				//console.log( "Moving player to::" );
				//console.log( this.player.position );
				
				this.moving.path.shift();
				//console.log( "this.moving.path.length = " + this.moving.path.length );
				if( this.moving.path.length <= 0 ) {
					this.moving.status = false;
				} else {
					this.tooltips[ this.player.tooltipID ].changePosition(
						(( this.tiles[ this.moving.path[ 0 ] ].x * this.tileDims ) + this.tileDims ) + "px",
						(( this.tiles[ this.moving.path[ 0 ] ].y * this.tileDims ) + this.tileDims ) + "px"
					);
					
					var newDir = this.player.findDirection( this.tiles[ this.moving.path[ 0 ] ] );
					this.player.turn( newDir );
					//console.log( "Face: " + newDir );
				}
			}
		}
	},
	clearLevel: function ( grd, data, dims ) {
		this.removeChildren();
	},
	buildLevel: function ( grd, data, dims ) {
		//console.log( "Build game level" );
		this.resize();
		
		// Create Player
		this.player = new Player( grd, dims, this );
		
		this.colors = data.colors;
	
		for( i = 0; i < data.tiles.length; i++ ) {
			var tile = data.tiles[ i ];
			//console.log( tile );
			if( tile.type == "randomGem" ) {
				var newColor = this.getRandomColor();
				var newTile =  new Tile( grd, tile.x, tile.y, dims, newColor, this, this.tiles.length );
				if( tile.edges.n == true ) {
					newTile.addClass( 'northEdge' );
				}
				if( tile.edges.e == true ) {
					newTile.addClass( 'eastEdge' );
				}
				if( tile.edges.s == true ) {
					newTile.addClass( 'southEdge' );
				}
				if( tile.edges.w == true ) {
					newTile.addClass( 'westEdge' );
				}
				this.tiles.push( newTile );
			}
			if( tile.type == "playerStart" ) {
				var newTile =  new Tile( grd, tile.x, tile.y, dims, und, this, this.tiles.length, "start" );
				if( tile.edges.n == true ) {
					newTile.addClass( 'northEdge' );
				}
				if( tile.edges.e == true ) {
					newTile.addClass( 'eastEdge' );
				}
				if( tile.edges.s == true ) {
					newTile.addClass( 'southEdge' );
				}
				if( tile.edges.w == true ) {
					newTile.addClass( 'westEdge' );
				}
				this.tiles.push( newTile );
				
				this.player.position.x = tile.x;
				this.player.position.y = tile.y;
			}
			if( tile.type == "playerEnd" ) {
				var newColor = this.getRandomColor();
				var newTile =  new Tile( grd, tile.x, tile.y, dims, newColor, this, this.tiles.length, "finish" );
				if( tile.edges.n == true ) {
					newTile.addClass( 'northEdge' );
				}
				if( tile.edges.e == true ) {
					newTile.addClass( 'eastEdge' );
				}
				if( tile.edges.s == true ) {
					newTile.addClass( 'southEdge' );
				}
				if( tile.edges.w == true ) {
					newTile.addClass( 'westEdge' );
				}
				this.tiles.push( newTile );
			}
		}
	},
	getRandomColor: function () {
		return this.colors[ Math.floor(Math.random() * this.colors.length) ];
	},
	removeChildren: function () {
		var grid = document.getElementById("grid");
		while (grid.firstChild) {
			grid.removeChild( grid.firstChild );
		}
	},
	resize: function () {
		var width = document.getElementById( "grid" ).offsetWidth;
		//console.log( "grid width: " + this.width  );
		
		// This needs to figure out the largest square that fits?
	},
	mouseMove: function ( m ) {
		var selectedTile = parseInt( m.target.dataset.id );
		// Sometimes these x/y values aren't found
		//console.log( this.tiles[ selectedTile ] );
		var mp = {
			x: this.tiles[ selectedTile ].x,
			y: this.tiles[ selectedTile ].y
		};
	//	console.log( "TileID to use " + selectedTile );
		if( selectedTile != und ) {
		//	console.log( this.dragPath.tiles );
			
			// check if this is in the stack
			var inStack = this.dragPath.tiles.indexOf( selectedTile );
		//	console.log( inStack );
			
			// check if this is the right color
			var tileColor = this.tiles[ selectedTile ].gemColor;
			
			var lastTileNum = this.dragPath.tiles[ this.dragPath.tiles.length - 1 ];
			// check to see if it's next to this
			var lastPos = {
				x: this.tiles[ lastTileNum ].x,
				y: this.tiles[ lastTileNum ].y
			};
		//	console.log( lastPos );
			var diffX = Math.abs( lastPos.x - mp.x );
			var diffY = Math.abs( lastPos.y - mp.y );
			var diff = Math.abs( ( lastPos.x - mp.x ) + ( lastPos.y - mp.y ) );
			
			if( inStack == -1 && tileColor == this.dragPath.color 
				&& diff == 1 && diffX <=1 && diffY <= 1 ) {
				this.dragPath.tiles.push( selectedTile );
				this.dragPath.lastTile = selectedTile;
				this.dragPath.lastX = this.tiles[ selectedTile ].x;
				this.dragPath.lastY = this.tiles[ selectedTile ].y;
				
				this.tiles[ selectedTile ].selectTile();

			} else if( inStack != -1 ) {
		//		console.log( selectedTile + " was found in the stack." );
				var valAt = this.dragPath.tiles.length - 1;
				if( inStack < valAt ) {
					for( i = valAt; i < this.dragPath.tiles.length; i++ ) {
						document.getElementById( "tile-" + this.dragPath.tiles[ i ] ).classList.remove( "active" );
						
					}
					
					this.dragPath.tiles.length = valAt;
					this.dragPath.lastTile = this.dragPath.tiles[ this.dragPath.tiles.length ];
					
				}
			}
		}
	},
	releaseTrigger: function () {
		if( this.mouseDown == true ) {
			this.mouseDown = false;
			var tileCount = this.dragPath.tiles.length;
			var msgHolder = document.getElementById( "msg" );
			var scoreHolder = document.getElementById( "score" );
			
			if( tileCount >= this.dragPath.minimum ) {
				msgHolder.innerHTML = "Number of Tiles selected: " + tileCount;
				this.score += tileCount;
				scoreHolder.innerHTML = "Score: " + this.score;
				
				//console.log( "Clear these" );
				//console.log( this.dragPath.tiles );
				
				var playerFound = { bool: false };
				for( i = 0; i < this.dragPath.tiles.length; i++ ) {
					if( playerFound.bool == false) {
						// check around this compass point for player
						var tile = this.tiles[ this.dragPath.tiles[ i ] ];
					/*	console.log( "Check: " + ( tile.x ) + ", " + ( tile.y )  );
						console.log( "Check: " + ( tile.x - 1 ) + ", " + ( tile.y ) + " for the player (" + this.player.position.x + ", " + this.player.position.y + ")" );
						console.log( "Check: " + ( tile.x + 1 ) + ", " + ( tile.y ) + " for the player (" + this.player.position.x + ", " + this.player.position.y + ")" );
						console.log( "Check: " + ( tile.x ) + ", " + ( tile.y - 1 ) + " for the player (" + this.player.position.x + ", " + this.player.position.y + ")" );
						console.log( "Check: " + ( tile.x ) + ", " + ( tile.y + 1 ) + " for the player (" + this.player.position.x + ", " + this.player.position.y + ")" );
					*/	
						// If the player is at one of these spots, move the player up the other spots
						
						if( tile.x == this.player.position.x && tile.y - 1 == this.player.position.y ) {
							playerFound.bool = true;
							playerFound.foundAt = i;
							playerFound.path = this.dragPath.tiles.slice( i, this.dragPath.tiles.length );
							playerFound.direction = "north";
						}
						if( tile.x + 1 == this.player.position.x && tile.y == this.player.position.y ) {
							playerFound.bool = true;
							playerFound.foundAt = i;
							playerFound.path = this.dragPath.tiles.slice( i, this.dragPath.tiles.length );
							playerFound.direction = "east";
						}
						if( tile.x == this.player.position.x && tile.y + 1 == this.player.position.y ) {
							playerFound.bool = true;
							playerFound.foundAt = i;
							playerFound.path = this.dragPath.tiles.slice( i, this.dragPath.tiles.length );
							playerFound.direction = "south";
						}
						if( tile.x - 1 == this.player.position.x && tile.y == this.player.position.y ) {
							playerFound.bool = true;
							playerFound.foundAt = i;
							playerFound.path = this.dragPath.tiles.slice( i, this.dragPath.tiles.length );
							playerFound.direction = "west";
						}
						
					}
				}
				//this.dragPath.tiles
				//console.log( "The player was found at::" );
				//console.log( playerFound );
				
				if( playerFound.bool == false ) {
					for( i = 0; i < this.dragPath.tiles.length; i++ ) {
						this.tiles[ this.dragPath.tiles[ i ] ].flipTile( this.getRandomColor() );
					}
				
				} else {
					console.log( "Player movement GO GO GO" );
					
					var playerAt = this.findDivAt( this.player.position.x, this.player.position.y );
					
					this.startMovement( playerAt, playerFound.path );
					
					var newDir = this.player.findDirection( this.tiles[ playerFound.path[ 0 ] ] );
					this.player.turn( newDir );
					
					// @andymakesthings
					// This whole block needs to just be stored in this.moving and set this.moving.status set to true
					// later this.update will move when this.moving.status == true
					// @andymakesthings
					// @andymakesthings - pretty sure this is working correctly
					/*
					// clear the tile the player is currently on
					console.log( "Player is on tile: " + playerAt.number );
						this.tiles[ playerAt.number ].flipTile( this.getRandomColor() );
					
					for( i = 0; i < this.dragPath.tiles.length - 1; i++ ) {
						console.log( "Flip tile num: " + this.dragPath.tiles[ i ] ); // we will clear and flip later
						this.tiles[ this.dragPath.tiles[ i ] ].flipTile( this.getRandomColor() );
						this.player.position.change( this.tiles[ this.dragPath.tiles[ i ] ].x,
							this.tiles[ this.dragPath.tiles[ i ] ].y,
							this.tileDims );
					}
					console.log( this.dragPath.tiles );
					var finalTile = this.tiles[ this.dragPath.tiles[ this.dragPath.tiles.length - 1 ] ];
					console.log( finalTile );
					finalTile.clearTile( );
					this.player.position.change( finalTile.x, finalTile.y, this.tileDims );
					
					this.player.steps += playerFound.path.length;
					*/
					
					
				}
				console.log( "Cleared" );
				
			} else {
				msgHolder.innerHTML = "Not enough Tiles selected (" + tileCount + " of " + this.dragPath.minimum + ")";
			}
			
			// clear the data
			this.dragPath.tiles.length = 0;
			this.dragPath.color = '';
			this.dragPath.lastTile = {};
			this.dragPath.lastX = 0;
			this.dragPath.lastY = 0;
			
			var tiles = document.getElementsByClassName( "tile" );
			var tileCount = tiles.length;
			for( x = 0; x < tileCount; x++ ) {
				tiles[ x ].classList.remove( "active" );
			}
			
		}
		
	},
	startDrag: function ( caller ) {
		if( !this.moving.status ) {
		//	console.log( "ID = " + caller.dataset.id );
			var callerID = parseInt( caller.dataset.id ); // can we can this?
		//	console.log( this.tiles[ caller.dataset.id ].gemColor );
			this.mouseDown = true;
			caller.classList.add( "active" );
			this.dragPath.color = caller.dataset.gemColor;
			
			var pos = {};
				pos.y = parseInt( caller.style.top ) / this.tileDims;
				pos.x = parseInt( caller.style.left ) / this.tileDims;
			this.dragPath.tiles.push( parseInt( caller.dataset.id ) );
			this.dragPath.lastTile = pos;
			this.dragPath.lastX = pos.x;
			this.dragPath.lastY = pos.y;
		}
	},
	findDivAt: function ( x, y ) {
		for( i = 0; i < this.tiles.length; i++ ) {
			if( this.tiles[ i ].x == x && this.tiles[ i ].y == y ) {
				return {
					'tile': this.tiles[ i ],
					'number': i
				};
			}
		}
	},
	showToolTip: function ( id ) {
		var ttEle = document.getElementById( "tooltip" );
		ttEle.style.top = this.tooltips[ id ].pos.y;
		ttEle.style.left = this.tooltips[ id ].pos.x;
		ttEle.innerHTML = this.tooltips[ id ].text;
		ttEle.classList.add( 'active' );
	},
	hideToolTip: function ( id ) {
		var ttEle = document.getElementById( "tooltip" );
		ttEle.style.top = "0px";
		ttEle.style.left = "0px";
		ttEle.innerHTML = "";
		ttEle.classList.remove( 'active' );
	},
	startMovement: function ( playerStart, path ) {
		console.log( "Player start at " + this.tiles[ playerStart ] + " and travels along:" );
		console.log( path );
		
		this.moving.status = true;
		this.moving.path = path;
	},
};

window.onresize = resize;
function resize() { 
	game.resize();
}

// release all
window.addEventListener("mouseup", function(){
	game.releaseTrigger();
}, false);

// Add mouse position tracking
window.onmousemove = function ( e ) {
	if( game.mouseDown == true ) {
	//	console.log( e );
		game.mouseMove( e );
	}
}

// add animation states
function animate() {
	requestAnimationFrame( animate ); // only reqeust an update when needed?
	game.update( );
}

var grd = document.getElementById( "grid" );
game.init( grd, 50 );
game.buildLevel( grd, levelData, 50 );
animate();
</script>

</body>
</html>